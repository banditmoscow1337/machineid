//go:build windows

package machineid

import (
	"bytes"
	"fmt"
	"os/exec"
	"strings"
	"unsafe"

	"golang.org/x/sys/windows"
	"golang.org/x/sys/windows/registry"
)

// getMachineID attempts to find a stable, unique identifier for the Windows machine.
// It follows a strict priority order to balance stability (persistence across re-installs) vs. availability.
func getMachineID() (string, error) {
	// 1. Priority: Motherboard UUID (SMBIOS)
	// This is burned into the hardware. It is the most stable ID as it persists
	// even if Windows is completely re-installed.
	// We use the native Windows API (GetSystemFirmwareTable) to read this, avoiding external CLI calls like 'wmic'.
	uuid, err := getBiosUUID()
	if err == nil && uuid != "" && uuid != "FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF" {
		return uuid, nil
	}

	// 2. Fallback: Disk Serial Number
	// If BIOS UUID is missing or generic (all F's), we try the primary disk's serial number.
	// This also typically persists across OS re-installs.
	disk, err := getWmic("diskdrive", "serialnumber")
	if err == nil && disk != "" {
		return disk, nil
	}

	// 3. Last Resort: Registry MachineGuid
	// Located at HKLM\SOFTWARE\Microsoft\Cryptography\MachineGuid.
	// This ID is generated by Windows during installation. It is unique, but it WILL change
	// if the user re-installs Windows.
	return getRegistryID()
}

// getBiosUUID fetches the machine UUID from the SMBIOS firmware table using the Windows API.
// Reference: https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getsystemfirmwaretable
func getBiosUUID() (string, error) {
	// 'RSMB' is the Little-Endian signature for the Raw SMBIOS provider (0x52534D42).
	const rsmb = 0x52534D42

	k32 := windows.NewLazySystemDLL("kernel32.dll")
	proc := k32.NewProc("GetSystemFirmwareTable")

	// 1. Determine the buffer size required to hold the SMBIOS table.
	// Passing 0 for buffer and size returns the required size.
	r1, _, _ := proc.Call(uintptr(rsmb), 0, 0, 0)
	if r1 == 0 {
		return "", fmt.Errorf("failed to get firmware table size")
	}

	size := r1
	buf := make([]byte, size)

	// 2. Retrieve the actual SMBIOS table data.
	r1, _, _ = proc.Call(uintptr(rsmb), 0, uintptr(unsafe.Pointer(&buf[0])), size)
	if r1 != size {
		return "", fmt.Errorf("failed to retrieve firmware table")
	}

	// Parse RawSMBIOSData structure:
	// struct RawSMBIOSData {
	//   BYTE  Used20CallingMethod;
	//   BYTE  SMBIOSMajorVersion;
	//   BYTE  SMBIOSMinorVersion;
	//   BYTE  DmiRevision;
	//   DWORD Length;          <-- 4 bytes indicating the size of the data following
	//   BYTE  SMBIOSTableData[];
	// }
	// We skip the 8-byte header to access the Table Data directly.
	if len(buf) < 8 {
		return "", fmt.Errorf("buffer too small")
	}

	data := buf[8:]
	return findUUIDInSMBIOS(data)
}

// findUUIDInSMBIOS iterates through the SMBIOS structures to find Type 1 (System Information).
func findUUIDInSMBIOS(data []byte) (string, error) {
	// SMBIOS data is a sequence of structures.
	// Header format: [Type (1b)] [Length (1b)] [Handle (2b)] ... [Data] ... [Double Null \0\0]
	i := 0
	for i < len(data) {
		if i+4 > len(data) {
			break
		}
		typ := data[i]
		length := int(data[i+1])

		if i+length > len(data) {
			break
		}

		// Type 1 = System Information (contains UUID).
		if typ == 1 {
			// Offset 0x08 (8) is where the UUID starts within the Type 1 structure.
			// The structure length must be at least 0x19 (25 bytes) to hold the 16-byte UUID.
			if length >= 25 {
				uuidBytes := data[i+8 : i+24]
				return formatSMBIOSUUID(uuidBytes), nil
			}
		}

		// Move to the next structure.
		// The unformatted data section ends with a double-null terminator (0x00 0x00).
		i += length
		for i+1 < len(data) {
			if data[i] == 0 && data[i+1] == 0 {
				i += 2 // Skip the double null
				break
			}
			i++
		}
	}
	return "", fmt.Errorf("uuid not found in smbios")
}

// formatSMBIOSUUID formats the 16 bytes into a standard UUID string.
// CRITICAL: SMBIOS 2.6+ specification dictates mixed-endian encoding for the UUID.
// - The first 3 fields (DWORD, WORD, WORD) are Little-Endian.
// - The last 2 fields (Char array) are Big-Endian (Network Byte Order).
// We must swap bytes in the first 3 fields to match the standard string representation.
func formatSMBIOSUUID(b []byte) string {
	// Check for invalid UUIDs (all zeros or all ones) often found in unconfigured hardware.
	if isAll(b, 0x00) || isAll(b, 0xFF) {
		return ""
	}

	return fmt.Sprintf("%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x",
		b[3], b[2], b[1], b[0], // Field 1: Swap DWORD (4 bytes)
		b[5], b[4],             // Field 2: Swap WORD (2 bytes)
		b[7], b[6],             // Field 3: Swap WORD (2 bytes)
		b[8], b[9], b[10], b[11], b[12], b[13], b[14], b[15]) // Remaining bytes are Big-Endian
}

func isAll(b []byte, v byte) bool {
	for _, x := range b {
		if x != v {
			return false
		}
	}
	return true
}

// getWmic executes the "wmic" command as a fallback mechanism.
func getWmic(target string, query string) (string, error) {
	// We invoke via 'cmd /c' to leverage the shell's handling of I/O, though direct invocation is possible.
	cmd := exec.Command("cmd", "/c", "wmic", target, "get", query)
	var out bytes.Buffer
	cmd.Stdout = &out
	err := cmd.Run()
	if err != nil {
		return "", err
	}

	// Sanitize Output: WMIC often outputs messy encodings (UTF-16 artifacts, null bytes).
	cleaned := strings.ReplaceAll(out.String(), "\x00", "")

	lines := strings.Split(cleaned, "\n")
	for _, line := range lines {
		trimmed := strings.TrimSpace(line)
		// Skip empty lines and the header (which repeats the query command).
		if trimmed == "" || strings.EqualFold(trimmed, query) {
			continue
		}
		return trimmed, nil
	}
	return "", nil
}

func getRegistryID() (string, error) {
	k, err := registry.OpenKey(registry.LOCAL_MACHINE, `SOFTWARE\Microsoft\Cryptography`, registry.QUERY_VALUE)
	if err != nil {
		return "", err
	}
	defer k.Close()

	id, _, err := k.GetStringValue("MachineGuid")
	if err != nil {
		return "", err
	}
	return id, nil
}